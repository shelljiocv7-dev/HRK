```python
from fastapi import FastAPI, File, UploadFile, BackgroundTasks
from fastapi.responses import JSONResponse
import os
import uuid
from celery import Celery

app = FastAPI()

# 配置Celery
celery_app = Celery('tasks', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')

# 上传目录
UPLOAD_DIR = "uploads"
os.makedirs(UPLOAD_DIR, exist_ok=True)

@app.post("/upload")
async def upload_audio(file: UploadFile = File(...)):
    file_id = str(uuid.uuid4())
    file_path = os.path.join(UPLOAD_DIR, f"{file_id}_{file.filename}")
    with open(file_path, "wb") as f:
        content = await file.read()
        f.write(content)
    # 保存文件信息到数据库（这里简化，实际需要数据库记录）
    return JSONResponse({"file_id": file_id, "filename": file.filename})

@app.get("/files/{file_id}/peaks")
async def get_peaks_endpoint(file_id: str):
    # 根据file_id找到文件路径
    # 假设我们通过file_id和文件名存储，这里需要根据实际存储方式获取
    # 例如，我们存储时记录了文件路径，这里直接使用
    file_path = find_file_path(file_id)
    if not file_path:
        return {"error": "File not found"}
    peaks = get_peaks(file_path)
    return {"peaks": peaks}

@app.post("/process")
async def process_audio(background_tasks: BackgroundTasks, request: ProcessRequest):
    # 提交处理任务到Celery
    task = process_audio_task.delay(request.file_id, request.operations, request.export_format, request.bitrate)
    return {"job_id": task.id}

@app.get("/process/{job_id}/status")
async def get_process_status(job_id: str):
    task = celery_app.AsyncResult(job_id)
    return {"status": task.status, "result": task.result}

@app.get("/files/{file_id}/download")
async def download_file(file_id: str):
    # 根据file_id找到处理后的文件路径
    file_path = find_processed_file_path(file_id)
    if not file_path:
        return {"error": "File not found"}
    return FileResponse(file_path)

# Celery任务
@celery_app.task
def process_audio_task(file_id, operations, export_format, bitrate):
    # 处理音频，根据operations依次执行操作
    # 这里需要根据operations的类型调用相应的处理函数
    # 处理完成后，保存文件，并返回处理后的文件路径
    pass
```